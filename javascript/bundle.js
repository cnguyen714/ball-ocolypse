/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./javascript/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./javascript/Beam.js":
/*!****************************!*\
  !*** ./javascript/Beam.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector */ \"./javascript/Vector.js\");\n/* harmony import */ var _EnemyCircle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EnemyCircle */ \"./javascript/EnemyCircle.js\");\n/* harmony import */ var _Explosion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Explosion */ \"./javascript/Explosion.js\");\n/* harmony import */ var _Particle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Particle */ \"./javascript/Particle.js\");\n/* harmony import */ var _SlashSpark__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SlashSpark */ \"./javascript/SlashSpark.js\");\n\n\n\n\n\n\n\nconst WIDTH = 60;\nconst LENGTH = 150;\nconst HITBOX_RATIO = 0.95;\nconst KNOCKBACK = 10;\nconst DAMAGE = 80;\nconst DURATION = 20;\n// const COLOR = \"white\";\n\nconst COLOR = {\n  NORMAL: [255,255,255],\n  CRIT: [255,255,0],\n  CANNON: [0,0,0]\n}\n\nclass Beam extends _Particle__WEBPACK_IMPORTED_MODULE_3__[\"default\"] {\n  constructor(game, startX, startY, aim, combo = 0) {\n    super(game, startX, startY);\n    this.aim = aim || this.game.player.aim.dup();\n    this.combo = combo || 0;\n\n    // Formula to get the radian angle between the Y axis and a point\n    this.angle = Math.atan2(this.aim.y, this.aim.x);\n\n    this.width = WIDTH;\n    this.length = LENGTH;\n    this.origin = new _Vector__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this.pos.x);\n    this.damage = DAMAGE;\n    this.knockback = KNOCKBACK;\n    this.aliveTime = DURATION;\n    // this.activeTime = 5;\n    this.active = true;\n    this.initialTime = this.aliveTime;\n\n    // this.update = this.update.bind(this);\n    // this.draw = this.draw.bind(this);\n  }\n\n\n  checkCollision(obj) {\n    if (!obj.alive) return; //Don't check collision if object is not alive\n    if (!this.active) return;\n\n    if(!this.hitWidth) this.hitWidth = this.width * HITBOX_RATIO;\n    if(!this.hitLength) this.hitLength = this.length * HITBOX_RATIO;\n\n    if (obj instanceof _EnemyCircle__WEBPACK_IMPORTED_MODULE_1__[\"default\"]) {\n\n      let x = this.pos.x;\n      let y = this.pos.y;\n\n      // === Infinite linear collision detection ===\n      // let dist = Math.abs(this.aim.x * diff.y - this.aim.y * diff.x) / this.aim.length();\n      // if (this.width / 2 + obj.r > dist) {\n      // =============\n\n      // === Translate positions to unrotated box, then box collision\n      // Invert Y axis because canvas uses Y axis pointing down, and most cartesian\n      // calculations are using Y axis up\n      // --------------\n      // calculate obj's relative position to beam origin\n      // x′=xcosθ−ysinθ      \n      // y′=ycosθ + xsinθ\n      \n      // Get the obj relative position to beam origin pos\n      let diff = _Vector__WEBPACK_IMPORTED_MODULE_0__[\"default\"].difference(new _Vector__WEBPACK_IMPORTED_MODULE_0__[\"default\"](obj.pos.x, -obj.pos.y), new _Vector__WEBPACK_IMPORTED_MODULE_0__[\"default\"](x, -y));\n\n      let x2 = diff.x * Math.cos(this.angle) - diff.y * Math.sin(this.angle);\n      let y2 = diff.y * Math.cos(this.angle) + diff.x * Math.sin(this.angle);\n\n      // Collision using obj as a box,\n      // Use LENGTH > HIT_LENGTH to hide inaccuracy of hitbox\n      if ( \n        x2 + obj.r >= 0 &&\n        x2 - obj.r <= 0 + this.hitLength &&\n        y2 + obj.r >= 0 - this.hitWidth / 2 &&\n        y2 - obj.r <= 0 + this.hitWidth / 2\n      ) {\n        diff = new _Vector__WEBPACK_IMPORTED_MODULE_0__[\"default\"](1,0);\n        let x = diff.x * Math.cos(this.angle) - diff.y * Math.sin(this.angle);\n        let y = diff.y * Math.cos(this.angle) + diff.x * Math.sin(this.angle);\n\n        // Invert Y axis again to use diff vector for knockback\n        // diff.multiply(new Vector(1, -1));\n        // if (this.combo === -2) {\n          let knockStraight = new _Vector__WEBPACK_IMPORTED_MODULE_0__[\"default\"](x, y);\n          // let knockStraight = this.game.player.aim.dup().normalize();\n          obj.vel.add(knockStraight.multiply(this.knockback));\n        // } else {\n        //   obj.vel.add(diff.multiply(this.knockback));\n        // }\n        obj.health -= this.damage;\n        if (obj.health <= 0) {\n          obj.alive = false;\n        } else {\n          if (this.combo === 3) {\n            this.game.playSoundMany(`${this.game.filePath}/assets/SE_00017.wav`, 0.03);\n            this.active = false;\n          } else {\n            this.game.playSoundMany(`${this.game.filePath}/assets/SE_00017.wav`, 0.08);\n          }\n        }\n        let color;\n        switch (this.combo) {\n          case 3:\n            this.game.vanity.push(new _SlashSpark__WEBPACK_IMPORTED_MODULE_4__[\"default\"](this.game, obj.pos.x - 50 + Math.random() * 100, obj.pos.y - 50 + Math.random() * 100, this.combo, Math.random() * 4, 30 + Math.random() * 70));\n            this.game.vanity.push(new _SlashSpark__WEBPACK_IMPORTED_MODULE_4__[\"default\"](this.game, obj.pos.x - 50 + Math.random() * 100, obj.pos.y - 50 + Math.random() * 100, this.combo, Math.random() * 4, 30 + Math.random() * 70));\n            break;\n          case -2:\n            this.game.vanity.push(new _SlashSpark__WEBPACK_IMPORTED_MODULE_4__[\"default\"](this.game, obj.pos.x, obj.pos.y, this.combo, 3 * obj.r, obj.r * 20, 20, Math.atan2(this.aim.y, this.aim.x)));\n            break;\n          case -1:\n            this.game.vanity.push(new _SlashSpark__WEBPACK_IMPORTED_MODULE_4__[\"default\"](this.game, obj.pos.x, obj.pos.y, this.combo, 15, 150, 50));\n            this.game.vanity.push(new _SlashSpark__WEBPACK_IMPORTED_MODULE_4__[\"default\"](this.game, obj.pos.x, obj.pos.y, 0, 4, 40));\n            this.game.vanity.push(new _SlashSpark__WEBPACK_IMPORTED_MODULE_4__[\"default\"](this.game, obj.pos.x, obj.pos.y, 0, 4, 60));\n            let explosion1 = new _Explosion__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this.game, obj.pos.x, obj.pos.y, 50);\n            explosion1.aliveTime = 3;\n            this.game.vanity.push(explosion1);\n\n            break;\n          default:\n            this.game.vanity.push(new _SlashSpark__WEBPACK_IMPORTED_MODULE_4__[\"default\"](this.game, obj.pos.x, obj.pos.y, this.combo, 3, 40));\n            this.game.vanity.push(new _SlashSpark__WEBPACK_IMPORTED_MODULE_4__[\"default\"](this.game, obj.pos.x, obj.pos.y, this.combo, 3, 40));\n            this.game.vanity.push(new _SlashSpark__WEBPACK_IMPORTED_MODULE_4__[\"default\"](this.game, obj.pos.x, obj.pos.y, this.combo, 3, 60));\n            this.game.vanity.push(new _SlashSpark__WEBPACK_IMPORTED_MODULE_4__[\"default\"](this.game, obj.pos.x, obj.pos.y, this.combo, 7, 90, 40));\n            let explosion = new _Explosion__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this.game, obj.pos.x, obj.pos.y, 30);\n            explosion.aliveTime = 3;\n            this.game.vanity.push(explosion);\n\n            break;\n        }\n      }\n    }    \n  }\n\n  drawRect() {\n    // Offset the rect based on its width but maintain origin\n    this.ctx.translate(this.pos.x + Math.sin(this.angle) * this.width / 2,\n                       this.pos.y - Math.cos(this.angle) * this.width / 2);\n    this.ctx.rotate(this.angle);\n    this.ctx.fillRect(0, 0, this.length, this.width);\n  }\n\n  update() {\n    if (!this.alive) return; //Don't check collision if object is not alive\n\n    //\n    if (this.aliveTime >= this.initialTime - 1 && this.active === true) {\n      this.game.entities.forEach(entity => { this.checkCollision(entity) });\n      // this.game.freeze(5);\n      if( this.combo === -2) {\n        let explosion = new _Explosion__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this.game, this.pos.x, this.pos.y, 100);\n        explosion.color = \"red\";\n        explosion.aliveTime = 7;\n        this.game.vanity.push(explosion);\n      }\n    }\n\n    if (this.aliveTime === this.initialTime - 2) {\n      this.width *= 1.5;\n    }\n    if (this.aliveTime > this.initialTime - 2) {\n    } else {\n      this.width *= 0.8;\n      this.length *= 0.99;\n    }\n\n    if (this.aliveTime <= 0) {\n      this.alive = false;\n    }\n    this.aliveTime--;\n    this.cb();\n  }\n\n  // ctx.arc(x, y, r, sAngle, eAngle, [counterclockwise])\n  draw() {\n    if (this.aliveTime > this.initialTime - 2) {\n      this.ctx.save();\n\n      this.ctx.fillStyle = this.color;\n      this.ctx.strokeStyle = this.color;\n      this.ctx.shadowColor = this.color;\n      this.ctx.strokeStyle = \"black\";\n\n      this.drawRect();\n\n      this.ctx.restore();\n    } else {\n      this.ctx.save();\n\n      this.ctx.shadowBlur = 20;\n      // this.ctx.shadowColor = \"white\";\n      this.ctx.shadowColor = `rgba(230,230,230,${Math.pow(this.aliveTime, 6)/ Math.pow(this.initialTime - 2, 6)})`;\n      // this.ctx.fillStyle = \"gray\";\n\n      this.ctx.fillStyle = `rgba(230,230,230,${Math.pow(this.aliveTime, 6) / Math.pow(this.initialTime - 2, 6)})`;\n      this.ctx.strokeStyle = \"white\";\n\n      this.drawRect();\n\n      this.ctx.restore();\n\n    }\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Beam);\n\n//# sourceURL=webpack:///./javascript/Beam.js?");

/***/ }),

/***/ "./javascript/BeamSlash.js":
/*!*********************************!*\
  !*** ./javascript/BeamSlash.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector */ \"./javascript/Vector.js\");\n/* harmony import */ var _EnemyCircle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EnemyCircle */ \"./javascript/EnemyCircle.js\");\n/* harmony import */ var _Explosion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Explosion */ \"./javascript/Explosion.js\");\n/* harmony import */ var _Particle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Particle */ \"./javascript/Particle.js\");\n/* harmony import */ var _Beam__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Beam */ \"./javascript/Beam.js\");\n\n\n\n\n\n\n\nconst WIDTH = 50;\nconst LENGTH = 150;\nconst KNOCKBACK = 7;\nconst DAMAGE = 200;\nconst DURATION = 7;\nconst ARC_DEGREE_RATE = 20;\nconst DERVISH_KB_RATE = 0.1;\nconst DIRECTION = {\n  CCW: -1,\n  CW: 1,\n}\n// const COLOR = \"white\";\n\n//\n// Beam factory that creates a new Beams in an arc over a duration\n//\nclass BeamSlash extends _Particle__WEBPACK_IMPORTED_MODULE_3__[\"default\"] {\n  constructor(game, \n      combo, \n      addOffset = 0,\n      width = WIDTH,\n      length = LENGTH) {\n    super(game);\n    this.owner = this.game.player;\n    this.pos = new _Vector__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this.owner.pos.x, this.owner.pos.y);\n    this.color = this.owner.color;\n    this.width = width;\n    this.length = length;\n    this.damage = DAMAGE;\n    this.aliveTime = DURATION;\n    this.directions = DIRECTION;\n    this.direction = DIRECTION.CW;\n    this.active = false;\n    this.arcRate = ARC_DEGREE_RATE * Math.PI / 180;\n    this.combo = combo;\n    this.knockback = KNOCKBACK;\n\n\n    switch(this.combo) {\n      case 0:\n        break;\n      case -1:\n        this.arcRate = (ARC_DEGREE_RATE * 1.1) * Math.PI / 180; \n        break;\n      case 1:\n        this.direction = DIRECTION.CCW;\n        this.aliveTime += 1;\n        this.damage *= 1.2;\n        break;\n      case 2:\n        this.damage *= 1.4;\n        break;\n      case 3:\n        this.direction = DIRECTION.CCW;\n        this.arcRate = (ARC_DEGREE_RATE) * Math.PI / 180; \n        this.aliveTime *= 12;\n        this.length *= 0.6;\n        this.width *= 0.4;\n        this.knockback *= DERVISH_KB_RATE;\n        this.damage /= 6;\n        break;\n      default:\n          break;\n    }\n\n    this.startOffsetDegree = -addOffset + ARC_DEGREE_RATE * (this.aliveTime / 2);\n\n\n    this.aim = this.owner.aim;\n    let angle = this.startOffsetDegree * Math.PI / 180 * this.direction;\n    angle += this.direction * 40 * Math.PI / 180;\n    let newAim = this.aim.dup();\n    newAim.multiply(1, -1);\n\n    let x2 = newAim.x * Math.cos(angle) - newAim.y * Math.sin(angle);\n    let y2 = newAim.y * Math.cos(angle) + newAim.x * Math.sin(angle);\n    // debugger\n    this.aim = new _Vector__WEBPACK_IMPORTED_MODULE_0__[\"default\"](-x2, -y2);\n  }\n\n  iterBeamArc() {\n    let arcRate = this.arcRate * this.direction;\n    let newAim = this.aim.dup();\n    newAim.multiply(1, -1);\n\n    let x2 = newAim.x * Math.cos(arcRate) - newAim.y * Math.sin(arcRate);\n    let y2 = newAim.y * Math.cos(arcRate) + newAim.x * Math.sin(arcRate);\n\n    // debugger\n    this.aim = new _Vector__WEBPACK_IMPORTED_MODULE_0__[\"default\"](x2, y2);\n\n    let p = new _Beam__WEBPACK_IMPORTED_MODULE_4__[\"default\"](this.game, this.pos.x, this.pos.y, this.aim, this.combo);\n    p.color = this.color;\n    p.length = this.length;\n    p.width = this.width;\n    p.damage = this.damage;\n    p.knockback = this.knockback;\n    if (this.combo === -1) {\n      this.length += 5;\n      this.width += 5;\n    } else if (this.combo === 3) {\n      this.pos.x = this.owner.pos.x;\n      this.pos.y = this.owner.pos.y;\n      this.length *= 0.99;\n    } else {\n      this.length -= 2;\n    }\n    this.game.particles.push(p);\n  }\n\n  checkCollision(obj) {\n    // BeamSlash does not check collision\n  }\n\n  update() {\n    if (!this.alive) return; \n\n    // this.pos.x = this.owner.pos.x;\n    // this.pos.y = this.owner.pos.y;\n\n    \n    this.iterBeamArc();\n    if (this.combo === -1 || this.combo === 3 || this.combo === 0) {\n      this.iterBeamArc();\n      this.aliveTime--;\n    }\n    if (this.combo === 3) {\n      this.iterBeamArc();\n      this.aliveTime--;\n    }\n\n    if (this.aliveTime <= 0) {\n      this.alive = false;\n\n      // combo finisher\n      if (this.combo === 3) {\n        this.game.playSoundMany(`${this.game.filePath}/assets/SE_00064.wav`, 0.22);\n        let slash = new BeamSlash(this.game, -1, 40);\n        slash.damage = this.damage * 12;\n        slash.color = \"orange\";\n        slash.knockback = this.knockback / DERVISH_KB_RATE * 1.5;\n        slash.aliveTime += 2;\n        slash.length += 30;\n        this.game.particles.push(slash);\n        this.game.player.invul = 5;\n      }\n    }\n    this.aliveTime--;\n    this.cb();\n  }\n\n  draw() {\n    // BeamSlash does not have any drawn elements\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (BeamSlash);\n\n//# sourceURL=webpack:///./javascript/BeamSlash.js?");

/***/ }),

/***/ "./javascript/EnemyCircle.js":
/*!***********************************!*\
  !*** ./javascript/EnemyCircle.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector */ \"./javascript/Vector.js\");\n/* harmony import */ var _Player__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Player */ \"./javascript/Player.js\");\n/* harmony import */ var _GameObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GameObject */ \"./javascript/GameObject.js\");\n/* harmony import */ var _Explosion__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Explosion */ \"./javascript/Explosion.js\");\n\n\n\n\n\n\nconst MAX_SPEED = 3;\nconst RADIUS = 7;\nconst COLOR = \"#a64942\";\nconst ACCEL = 1;\nconst KNOCKBACK = 10;\nconst ENEMY_KNOCKBACK_MULTIPLIER = 2.5;\nconst DAMPENING_COEFFICIENT = 0.7;\nconst SPREAD_FACTOR = 2.0;\nconst HEALTH = 100;\nconst HEALTH_CAP = 200;\nconst DAMAGE = 1;\nconst SCORE = 1;\n\nclass EnemyCircle extends _GameObject__WEBPACK_IMPORTED_MODULE_2__[\"default\"] {\n  constructor(game) {\n    super(game);\n    this.maxSpeed = MAX_SPEED;\n    this.accel = ACCEL;\n    this.aiCallback = () => {};\n\n    this.health = HEALTH + game.difficulty * 2;\n    if (this.health > HEALTH_CAP) this.health = HEALTH_CAP;\n\n    this.r = RADIUS;\n    this.color = COLOR;\n    this.damage = DAMAGE;\n    this.score = SCORE;\n\n    this.update = this.update.bind(this);\n    this.draw = this.draw.bind(this);\n  }\n\n  validatePosition(rectX, rectY) {\n\n  }\n\n  dampSpeed() {\n    let vel = this.vel.length();\n    if (vel > MAX_SPEED) {\n      this.vel.multiply(DAMPENING_COEFFICIENT);\n    }\n  }\n\n  // Check if enemies collide with the player\n  checkAndHitPlayer(player) {\n    if (player.noclip > 0) return;\n    let diff = _Vector__WEBPACK_IMPORTED_MODULE_0__[\"default\"].difference(this.pos, player.pos);\n    let distSqr = diff.dot(diff);\n\n    if (player.moveState === \"STATE_DASHING\") return;\n    if (this.r * this.r + player.r * player.r > distSqr) {\n      this.game.playSoundMany(`${this.game.filePath}/assets/impact.wav`, 0.3);\n      let explosion = new _Explosion__WEBPACK_IMPORTED_MODULE_3__[\"default\"](game, player.pos.x + diff.x / 2, player.pos.y + diff.y / 2, this.r * 2);\n      explosion.color = 'red';\n      explosion.aliveTime = 5;\n      \n      diff.normalize();\n      diff.multiply(KNOCKBACK);\n      player.vel.subtract(diff.dup().multiply(this.r / RADIUS));\n      this.vel.add(diff.multiply(ENEMY_KNOCKBACK_MULTIPLIER));\n      if (player.invul > 0) {\n        explosion.color = 'lightblue';\n      } else {\n        player.health -= this.damage;\n        player.charge += this.damage;\n        if (this.r > RADIUS) player.invul = 45;\n      }\n      player.game.vanity.push(explosion);\n    } \n  }\n\n  // Check if enemies are colliding and push them away\n  checkAndSpreadEnemy(obj) {\n    let diff = _Vector__WEBPACK_IMPORTED_MODULE_0__[\"default\"].difference(this.pos, obj.pos);\n    let distSqr = diff.dot(diff);\n\n    // Don't collide objects that are standing directly on each other\n    if (obj.pos.equals(this.pos)) return;\n    if (this.r * this.r + obj.r * obj.r > distSqr) {\n      diff.normalize();\n      diff.multiply(SPREAD_FACTOR);\n      obj.vel.subtract(diff.dup().multiply(this.r / RADIUS));\n      this.vel.add(diff.dup().multiply(RADIUS / this.r));\n    }\n  }\n\n  checkCollision(obj) {\n    if (!obj.alive) return;\n\n    if(obj instanceof _Player__WEBPACK_IMPORTED_MODULE_1__[\"default\"]) {\n      this.checkAndHitPlayer(obj);\n    } else if (obj instanceof EnemyCircle) {\n      this.checkAndSpreadEnemy(obj);\n    }\n  }\n\n  update() {\n    if (!this.alive) return;\n    this.aiCallback();\n\n    this.dampSpeed();\n    this.addVelocityTimeDelta();\n// this.validatePosition(this.cvs.width, this.cvs.height);\n\n    // Check collision with player\n    this.checkCollision(this.game.players[0]);\n\n    // Many-many collision is very heavy - please refactor at some point or implement quadtree\n    this.game.entities.forEach(entity => this.checkCollision(entity));\n  }\n\n  // ctx.arc(x, y, r, sAngle, eAngle, [counterclockwise])\n  draw() {\n    this.ctx.save();\n    this.ctx.beginPath();\n    this.ctx.arc(this.pos.x, this.pos.y, this.r, 0, 2 * Math.PI);\n    this.ctx.fillStyle = this.color;\n    this.ctx.strokeStyle = 'black';\n    this.ctx.fill();\n    this.ctx.stroke();\n    this.ctx.closePath();\n    this.ctx.restore();\n\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (EnemyCircle);\n\n//# sourceURL=webpack:///./javascript/EnemyCircle.js?");

/***/ }),

/***/ "./javascript/Explosion.js":
/*!*********************************!*\
  !*** ./javascript/Explosion.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector */ \"./javascript/Vector.js\");\n/* harmony import */ var _EnemyCircle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EnemyCircle */ \"./javascript/EnemyCircle.js\");\n/* harmony import */ var _Particle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Particle */ \"./javascript/Particle.js\");\n\n\n\n\nconst RADIUS = 5;\nconst COLOR = \"white\";\n\nclass Explosion extends _Particle__WEBPACK_IMPORTED_MODULE_2__[\"default\"] {\n  constructor(game, startX, startY, startR, vel) {\n    super(game);\n    this.pos = new _Vector__WEBPACK_IMPORTED_MODULE_0__[\"default\"](startX, startY);\n    this.vel = vel || new _Vector__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n    this.r = startR || RADIUS;\n    this.color = COLOR;\n    this.aliveTime = 20;\n    this.initialAliveTime = this.aliveTime;\n\n    this.update = this.update.bind(this);\n    this.draw = this.draw.bind(this);\n  }\n\n  update() {\n    if (!this.alive) return; //Don't check collision if object is not alive\n\n    this.pos.add(this.vel);\n    if (this.aliveTime <= 0) {\n      this.alive = false;\n    }\n    this.aliveTime--;\n\n    if (this.aliveTime <= 5) {\n      this.r *= 1.11;\n    }\n\n  }\n\n  // ctx.arc(x, y, r, sAngle, eAngle, [counterclockwise])\n  draw() {\n\n    if (this.aliveTime > 5) {\n      this.ctx.save();\n\n      this.ctx.beginPath();\n      this.ctx.arc(this.pos.x, this.pos.y, this.r, 0, 2 * Math.PI);\n      this.ctx.fillStyle = this.color;\n      this.ctx.strokeStyle = this.color;\n      this.ctx.fill();\n      this.ctx.stroke();\n      this.ctx.closePath();\n      this.ctx.restore();\n\n\n    } else {\n      this.ctx.save();\n\n      this.ctx.beginPath();\n      this.ctx.arc(this.pos.x, this.pos.y, this.r, 0, 2 * Math.PI);\n      this.ctx.fillStyle = \"rgba(0,0,0,0)\";\n      this.ctx.fill();\n      this.ctx.strokeStyle = this.color;\n     \n      this.ctx.shadowBlur = 30;\n      this.ctx.shadowColor =  this.color;\n      this.ctx.stroke();  \n\n      this.ctx.restore();    \n    }\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Explosion);\n\n//# sourceURL=webpack:///./javascript/Explosion.js?");

/***/ }),

/***/ "./javascript/Game.js":
/*!****************************!*\
  !*** ./javascript/Game.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Player__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Player */ \"./javascript/Player.js\");\n/* harmony import */ var _Particle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Particle */ \"./javascript/Particle.js\");\n/* harmony import */ var _Vector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Vector */ \"./javascript/Vector.js\");\n/* harmony import */ var _particle_factory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./particle_factory */ \"./javascript/particle_factory.js\");\n/* harmony import */ var _enemy_factory__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./enemy_factory */ \"./javascript/enemy_factory.js\");\n/* harmony import */ var _Slam__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Slam */ \"./javascript/Slam.js\");\n/* harmony import */ var _Beam__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Beam */ \"./javascript/Beam.js\");\n/* harmony import */ var _Explosion__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Explosion */ \"./javascript/Explosion.js\");\n/* harmony import */ var _GameObject__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./GameObject */ \"./javascript/GameObject.js\");\n/* harmony import */ var _SlashSpark__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./SlashSpark */ \"./javascript/SlashSpark.js\");\n\n\n\n\n\n\n \n \n\n\n\n\n\n// My laptop has a performance limit of around 700 particles\n// Delta time is implemented by accelerating movement to perceive less\n// lag, however the game still runs slower\n\n\n\n/*\nAccess this on localhost:8000 by running both:\nnpm start\npython -m SimpleHTTPServer\n\n===\n\nTo-do:\n\n- Impact frame? Flash white ==> black on beam shadow / etcs\n- Style Score box\n- Sword sound/ Beam sound\n\n*/\n\nconst PATH = document.URL.substr(0, document.URL.lastIndexOf('/'));\nconst STATE_INIT = \"STATE_INIT\";\nconst STATE_BEGIN = \"STATE_BEGIN\";\nconst STATE_RUNNING = \"STATE_RUNNING\";\nconst STATE_OVER = \"STATE_OVER\";\n\nconst FPS = 60;\nconst NORMAL_TIME_DELTA = 1000 / FPS;\nconst MIN_FRAME_RATE = 50; // Limits enemy production to save frames\n\nconst BASE_SPAWN_RATE = 4; // 5\nconst DIFFICULTY_START = 1;\nconst DIFFICULTY_INTERVAL = 60;\nconst DIFFICULTY_MULTIPLIER = 0.035;\nconst DIFFICULTY_RATE = 1;\nconst MAX_DIFFICULTY = 80;\n\n\nconst STARTING_HEALTH = 250;\n\nconst MUTE = new Image(50,50);\nMUTE.src = `${PATH}/assets/mute.png`;\nconst VOL = new Image(50, 50);\nVOL.src = `${PATH}/assets/volume.png`;\nconst WASD = new Image();\nWASD.src = `${PATH}/assets/WASD.png`;\nconst LEFT_MOUSE_ICON = new Image();\nLEFT_MOUSE_ICON.src = `${PATH}/assets/left.png`;\nconst RIGHT_MOUSE_ICON = new Image();\nRIGHT_MOUSE_ICON.src = `${PATH}/assets/right.png`;\nconst SPACEBAR_ICON = new Image();\nSPACEBAR_ICON.src = `${PATH}/assets/spacebar.png`;\n\nclass Game {\n  constructor(cvs, ctx) {\n    this.STATE_INIT = STATE_INIT;\n    this.STATE_BEGIN = STATE_BEGIN;\n    this.STATE_RUNNING = STATE_RUNNING;\n    this.STATE_OVER = STATE_OVER;\n    this.cvs = cvs;\n    this.ctx = ctx;\n    this.highscore = 0;\n    this.score = 0;\n    this.pauseTime = 0;\n    this.mute = false;\n    this.filePath = PATH;\n\n    this.timeTracker = (new Date).getTime() + NORMAL_TIME_DELTA;\n    this.prevTime = (new Date).getTime();\n\n    this.state = STATE_INIT;\n\n    this.defeatSfx = new Audio(`${PATH}/assets/DEFEATED.wav`);\n    this.enemyDeathSfx = new Audio(`${PATH}/assets/boom2.wav`);\n    this.playerShootSfx = new Audio(`${PATH}/assets/laser7.wav`);\n    this.playerSlashSfx = new Audio(`${PATH}/assets/SE_00064.wav`);\n    this.playerBeamSfx = new Audio(`${PATH}/assets/SE_00049.wav`);\n    this.playerChargeSfx = new Audio(`${PATH}/assets/SE_00016.wav`);\n    this.bgm = new Audio(`${PATH}/assets/305_Battlefield_-_Swords_Bursting.mp3`);\n    this.bgm.loop = true;\n\n    this.init = this.init.bind(this);\n    this.loop = this.loop.bind(this);\n  }\n\n  init() {\n    this.ctx.canvas.width = window.innerWidth;\n    this.ctx.canvas.height = window.innerHeight;\n\n    this.score = 0;\n    this.loops = 0;\n    this.loopCount = 0;\n    this.timeSeconds = 0;\n    this.difficulty = DIFFICULTY_START;\n    this.difficultyRate = DIFFICULTY_RATE;\n    // this.spawnRate = SPAWN_RATE;\n    this.fpsCount = 0;\n    this.fps = 0;\n    this.timeDelta = NORMAL_TIME_DELTA;\n    this.normalTimeDelta = NORMAL_TIME_DELTA;\n    \n    this.players = [];\n    this.player = new _Player__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this);\n    this.player.alive = false;\n    this.players.push(this.player);\n    this.cameraPos = new _Vector__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this.player.pos.x, this.player.pos.y);\n    \n    this.entities = [];\n    this.particles = [];\n    this.delayedParticles = [];\n    this.vanity = [];\n    this.menus = [];\n\n    this.player.mountController();\n    this.state = STATE_BEGIN;\n\n    let startGameMenu = new _GameObject__WEBPACK_IMPORTED_MODULE_8__[\"default\"](game);\n    startGameMenu.pos.x = 0,\n    startGameMenu.pos.y = this.cvs.height / 2;\n    startGameMenu.height = 0;\n    startGameMenu.width = this.cvs.width;\n    startGameMenu.color = \"rgba(0,0,0,0.4)\";\n    startGameMenu.aliveTime = 60;\n    startGameMenu.time = this.timeSeconds;\n    startGameMenu.difficulty = this.difficulty;\n    startGameMenu.alpha = 0;\n    startGameMenu.draw = function () {\n      this.aliveTime--;\n      this.ctx.save();\n      this.ctx.fillStyle = this.color;\n      this.ctx.fillRect(0, this.cvs.height / 2 - this.cvs.height / 8 * (60 - this.aliveTime) / 60, this.cvs.width, this.cvs.height / 4 * (60 - this.aliveTime) / 60);\n      if (this.aliveTime <= 0) {\n        if (this.alpha < 1) this.alpha += 0.3;\n        this.aliveTime = 0;\n        let xOffset = this.cvs.width / 2;\n        let yOffset = this.cvs.height - 250;\n        this.ctx.textAlign = 'center';\n\n        this.ctx.fillStyle = `rgba(0,128,128,${this.alpha})`;\n        this.ctx.font = `${this.cvs.height / 8}px sans-serif`;\n        // this.ctx.fillText(`Ball-popcalypse`, this.cvs.width * 0.4 / 16, this.cvs.height * 17/32 );\n        this.ctx.fillText(`Ball-popcalypse`, this.cvs.width / 2, this.cvs.height * 17/32 );\n        this.ctx.fillStyle = `rgba(128,128,128,${this.alpha})`;\n        this.ctx.font = `${this.cvs.height / 32}px sans-serif`;\n        this.ctx.fillText(`How long can you survive the ball menace?`, this.cvs.width / 2, this.cvs.height * 19/32 );\n\n        this.ctx.fillStyle = \"white\";\n        this.ctx.font = '20px sans-serif';\n        this.ctx.shadowBlur = 4;\n        this.ctx.shadowColor = 'black';\n        \n        this.ctx.fillText(`Press a key or mousebutton to start`, xOffset , yOffset);\n        this.ctx.drawImage(WASD, xOffset -= 350, yOffset + 40, 180, 150);\n        this.ctx.fillText(`Movement`, xOffset + 85, yOffset + 210);\n        this.ctx.drawImage(LEFT_MOUSE_ICON, xOffset += 190, yOffset + 13, 200, 180);\n        this.ctx.fillText(`Slash`, xOffset + 100, yOffset + 210);\n        this.ctx.drawImage(RIGHT_MOUSE_ICON, xOffset += 190, yOffset + 43, 120, 150);\n        this.ctx.fillText(`Blaster`, xOffset + 50, yOffset + 210);\n        this.ctx.drawImage(SPACEBAR_ICON, xOffset += 170, yOffset + 113, 200, 80);\n        this.ctx.fillText(`Cannon`, xOffset + 90, yOffset + 210);\n        this.ctx.fillText(`Spacebar`, xOffset + 65, yOffset + 150);\n      }\n      this.ctx.restore();\n    }\n    \n    this.menus.push(startGameMenu);\n    this.entities.push(_enemy_factory__WEBPACK_IMPORTED_MODULE_4__[\"spawnCircleRandom\"](this.player));\n    this.entities.push(_enemy_factory__WEBPACK_IMPORTED_MODULE_4__[\"spawnCircleRandom\"](this.player));\n    this.entities.push(_enemy_factory__WEBPACK_IMPORTED_MODULE_4__[\"spawnCircleRandom\"](this.player));\n    this.entities.push(_enemy_factory__WEBPACK_IMPORTED_MODULE_4__[\"spawnCircleRandom\"](this.player));\n    this.entities.push(_enemy_factory__WEBPACK_IMPORTED_MODULE_4__[\"spawnCircleRandom\"](this.player));\n\n    this.bgm.pause();\n  }\n\n  startGame() {\n    this.loopCount = 0;\n    this.state = STATE_RUNNING;\n    this.menus = [];\n    this.entities = [];\n    this.vanity = [];\n    this.player.alive = true;\n    this.player.maxHealth = STARTING_HEALTH;\n    this.player.health = STARTING_HEALTH;\n    this.particles.push(new _Slam__WEBPACK_IMPORTED_MODULE_5__[\"default\"](game, this.player.pos.x, this.player.pos.y));\n    this.playSound(this.bgm, 0.4);\n    this.bgm.currentTime = 0;\n  }\n\n  endGame() {\n    this.state = STATE_OVER;\n    this.freeze(10);\n    this.player.alive = false;\n    this.player.color = 'black'; \n    this.playSound(this.defeatSfx, 0.2);\n\n    let explode1 = new _Slam__WEBPACK_IMPORTED_MODULE_5__[\"default\"](game, this.player.pos.x, this.player.pos.y);\n    explode1.color = 'white';\n    explode1.knockback = 200;\n    explode1.damage = 0;\n    explode1.r = 310;\n    this.particles.push(explode1);\n    let explode2 = new _Slam__WEBPACK_IMPORTED_MODULE_5__[\"default\"](game, this.player.pos.x, this.player.pos.y);\n    explode2.color = 'gray';\n    explode2.knockback = 0;\n    explode2.damage = 50;\n    explode2.r = 300;\n    this.particles.push(explode2);\n    let explode3 = new _Slam__WEBPACK_IMPORTED_MODULE_5__[\"default\"](game, this.player.pos.x, this.player.pos.y);\n    explode3.color = 'black';\n    explode3.knockback = 0; \n    explode3.damage = 1000;\n    explode3.r = 100;\n    this.particles.push(explode3);\n\n    let drawEnd = function() {\n      let endGameMenu = new _GameObject__WEBPACK_IMPORTED_MODULE_8__[\"default\"](game);\n      endGameMenu.pos.x = 0,\n      endGameMenu.pos.y = this.cvs.height / 2;\n      endGameMenu.height = 0;\n      endGameMenu.width = this.cvs.width;\n      endGameMenu.color = \"rgba(0,0,0,0.5)\";\n      endGameMenu.aliveTime = 60;\n      endGameMenu.time = this.timeSeconds;\n      endGameMenu.difficulty = this.difficulty;\n      endGameMenu.draw = function() {\n        this.aliveTime--;\n        this.ctx.save();\n        this.ctx.fillStyle = this.color;\n        this.ctx.fillRect(0, this.cvs.height / 2 - this.cvs.height / 8 * (60 - this.aliveTime) / 60, this.cvs.width, this.cvs.height / 4 * (60 - this.aliveTime) / 60);\n        if (this.aliveTime <=0) {\n          this.aliveTime = 0;\n          this.ctx.fillStyle = 'white';\n          this.ctx.font = '20px sans-serif';\n          \n          this.ctx.fillText(`Score: ${this.game.score}`, this.cvs.width / 2 - 30, this.cvs.height / 2 - 40);\n          this.ctx.fillText(`Highscore: ${this.game.highscore}`, this.cvs.width / 2 - 30, this.cvs.height / 2 - 20 );\n          this.ctx.fillText(`Time: ${this.time}`, this.cvs.width / 2 - 30, this.cvs.height / 2 );\n          this.ctx.fillText(`Difficulty: ${this.difficulty.toFixed(2)}`, this.cvs.width / 2 - 30, this.cvs.height / 2 + 20);\n          this.ctx.fillText(`Press [Enter] to restart`, this.cvs.width / 2 - 60, this.cvs.height / 2 + 80);\n        }\n        this.ctx.restore();\n      }\n      if (this.state === STATE_OVER) this.menus.push(endGameMenu);\n    }\n    drawEnd = drawEnd.bind(this);\n    setTimeout(drawEnd, 2000);\n  }\n\n  restartGame() {\n    this.init();\n  }\n\n  playSound(sound, vol = 1) {\n    if (this.mute) return;\n    sound.volume = vol;\n    sound.play();\n  }\n\n  playSoundMany(path, vol = 1) {\n    if (this.mute) return;\n    let sound = new Audio(path);\n    sound.volume = vol;\n    sound.play();\n  }\n\n  // Freezes the entire game state for n frames\n  // Typically use this for hitstop\n  freeze(n) {\n    this.pauseTime = n;\n    this.vanity.forEach(entity => entity.paused = true);\n  }\n\n  update() {\n    this.loopCount++;\n    if (this.highscore < this.score) this.highscore = this.score;\n\n    switch(this.state) {\n      case STATE_INIT: \n        this.init();\n        break;\n\n      case STATE_BEGIN:\n        if (this.loopCount % 120 === 0 && this.fps >= MIN_FRAME_RATE && this.loopCount > 60) {\n          this.entities.push(_enemy_factory__WEBPACK_IMPORTED_MODULE_4__[\"spawnCircleRandom\"](this.player));\n          if (this.loopCount % 240 === 0) {\n            this.player.pos.x = 200 + Math.random() * (this.cvs.width - 200 * 2);\n            this.player.pos.y = 200 + Math.random() * (this.cvs.height - 200 * 2);\n          }\n        }\n        this.players.forEach(entity => entity.update());\n        this.entities.forEach(entity => entity.update());\n        this.particles.forEach(entity => entity.update());\n        break;\n\n      case STATE_RUNNING:\n\n        if (this.pauseTime === 0) {\n          this.vanity.forEach(entity => entity.paused = false);\n          this.particles = this.particles.concat(this.delayedParticles);\n          this.delayedParticles = [];\n        }\n\n        if (this.pauseTime > 0) {\n          this.vanity = this.vanity.filter(entity => entity.alive);\n          this.vanity.filter(entity => !entity.paused).forEach(entity => entity.update());\n        } else {\n          if (this.loopCount % DIFFICULTY_INTERVAL === 0) {\n            this.difficulty *= 1 + DIFFICULTY_MULTIPLIER * this.difficultyRate;\n          }\n          if (this.difficulty > 100) this.difficulty = MAX_DIFFICULTY;\n\n          // Generate enemies -\n          // Stop making enemies if you miss too many frame deadlines, also keep generating enemies if the FPS drop was to player using beam\n          let spawnRate = 20 - Math.floor(this.difficulty);\n          spawnRate = spawnRate <= 1 ? 1 : spawnRate;\n          if (this.loopCount % (BASE_SPAWN_RATE + spawnRate) === 0 && (this.fps >= MIN_FRAME_RATE || this.player.beamCooldown > 0) && this.loopCount > 60) {\n            this.entities.push(_enemy_factory__WEBPACK_IMPORTED_MODULE_4__[\"spawnCircleRandom\"](this.player));\n          }\n\n          // Handle enemy death\n          let soundLimit = 3;\n          let soundCount = 0;\n          this.entities.filter(entity => !entity.alive).forEach(entity => {\n            if (soundCount <= soundLimit) {\n              this.playSoundMany(`${PATH}/assets/boom2.wav`, 0.3);\n              soundCount++;\n            }\n            this.vanity.push(new _Explosion__WEBPACK_IMPORTED_MODULE_7__[\"default\"](game, entity.pos.x, entity.pos.y, entity.r * 1.5, entity.vel))\n\n            this.difficulty += 0.002 * this.difficultyRate;\n            this.score += entity.score;\n            this.player.charge++;\n          });\n\n          // Handle updates\n          this.player.update();\n          this.vanity = this.vanity.filter(entity => entity.alive);\n          this.vanity.forEach(entity => entity.update());\n          this.entities = this.entities.filter(entity => entity.alive);\n          this.entities.forEach(entity => entity.update());\n          this.particles.filter(entity => !entity.alive).forEach(entity => {\n            if (entity instanceof _Particle__WEBPACK_IMPORTED_MODULE_1__[\"default\"] && !(entity instanceof _Beam__WEBPACK_IMPORTED_MODULE_6__[\"default\"])) {\n              let hitspark = new _Slam__WEBPACK_IMPORTED_MODULE_5__[\"default\"](this, entity.pos.x, entity.pos.y);\n              hitspark.aliveTime = 4;\n              hitspark.growthRate = 1;\n              hitspark.r = 1;\n              hitspark.damage = 0;\n              this.vanity.push(hitspark);\n            }\n          });\n          this.particles = this.particles.filter(entity => entity.alive);\n          this.particles.forEach(entity => entity.update());\n\n          if (this.player.health <= 0) this.endGame();\n        }\n        break;\n\n      case STATE_OVER:\n        if (this.pauseTime > 0) return;\n\n        // this.player.update();\n\n        // if (this.loopCount % (Math.floor(SPAWN_RATE * 1.5)) === 0) {\n        if (this.loopCount % 2 === 0) {\n          this.entities.push(_enemy_factory__WEBPACK_IMPORTED_MODULE_4__[\"spawnCircleRandom\"](this.player));\n          // if (this.fps <= MIN_FRAME_RATE - 5) this.entities[0].alive = false;          \n        }\n        this.entities.forEach(entity => {\n          let diff = _Vector__WEBPACK_IMPORTED_MODULE_2__[\"default\"].difference(entity.pos, this.player.pos);\n          let distSqr = diff.dot(diff);\n\n          if (entity.r * entity.r + this.player.r * this.player.r  + 100 > distSqr) {\n            entity.alive = false;\n          }\n        })\n        this.entities.filter(entity => !entity.alive).forEach(entity => {\n          // if (this.loopCount % 5 === 0) {\n          //   let sound = new Audio(\"../assets/boom2.wav\");\n          //   sound.play();\n          // }\n          this.particles.push(new _Explosion__WEBPACK_IMPORTED_MODULE_7__[\"default\"](game, entity.pos.x, entity.pos.y, entity.r))\n        });\n        this.entities = this.entities.filter(entity => entity.alive);\n        this.entities.forEach(entity => entity.update());\n\n        this.particles = this.particles.filter(entity => entity.alive);\n        this.particles.forEach(entity => entity.update());\n\n        this.vanity = this.vanity.filter(entity => entity.alive);\n        this.vanity.forEach(entity => entity.update());\n\n        // this.restartGame();\n        break;\n      default:\n        break;\n    }\n  }\n\n  // Draw player reticle at mouse position\n  drawCursor() {\n    let cursorSize = 15;\n    this.ctx.save();\n    this.ctx.beginPath();\n    // this.ctx.arc(this.player.mousePos.x, this.player.mousePos.y, 4, 0, 2 * Math.PI);\n    // this.ctx.fillStyle = \"rgba(0,0,0,0)\";\n    this.ctx.strokeStyle = \"black\";\n    this.ctx.lineWidth = 4;\n    this.ctx.shadowBlur = 2;\n    this.ctx.shadowColor = 'white';\n    this.ctx.moveTo(this.player.mousePos.x - cursorSize - this.player.dashCooldown / 2, this.player.mousePos.y);\n    this.ctx.lineTo(this.player.mousePos.x + cursorSize + this.player.dashCooldown / 2, this.player.mousePos.y);\n    this.ctx.moveTo(this.player.mousePos.x, this.player.mousePos.y - cursorSize - this.player.dashCooldown / 2);\n    this.ctx.lineTo(this.player.mousePos.x, this.player.mousePos.y + cursorSize + this.player.dashCooldown / 2);\n    this.ctx.stroke();\n    this.ctx.closePath();\n    this.ctx.beginPath();\n    cursorSize = 14;\n    this.ctx.shadowBlur = 0;\n    this.ctx.lineWidth = 2;\n    if (this.player.charge >= this.player.chargeMax * 2) {\n      this.ctx.strokeStyle = \"lightblue\";\n    } else if (this.player.charge >= this.player.chargeMax) {\n      this.ctx.strokeStyle = \"red\";\n    } else {\n      this.ctx.strokeStyle = \"yellow\";\n    }\n    this.ctx.moveTo(this.player.mousePos.x - cursorSize - this.player.dashCooldown / 2, this.player.mousePos.y);\n    this.ctx.lineTo(this.player.mousePos.x + cursorSize + this.player.dashCooldown / 2, this.player.mousePos.y);\n    this.ctx.moveTo(this.player.mousePos.x, this.player.mousePos.y - cursorSize - this.player.dashCooldown / 2);\n    this.ctx.lineTo(this.player.mousePos.x, this.player.mousePos.y + cursorSize + this.player.dashCooldown / 2);\n    this.ctx.stroke();\n    \n    this.ctx.font = '20px sans-serif';\n    this.ctx.fillStyle = 'white';\n\n    // === DEBUG SHOW ANGLE\n    // let angle = Math.atan2(this.player.aim.y, this.player.aim.x);\n    // this.ctx.fillText(`Angle: ${angle / Math.PI * 180}`, this.player.mousePos.x, this.player.mousePos.y);\n\n    // this.ctx.fillRect(this.player.mousePos.x + 3, this.player.mousePos.y + 3, this.player.dashCooldown, 3);\n\n    this.ctx.restore();\n  }\n\n  drawFPS() {\n    this.ctx.save();\n    this.ctx.fillStyle = 'white';\n    this.ctx.font = '12px sans-serif';\n    this.ctx.shadowBlur = 2;\n    this.ctx.shadowColor = 'black';\n    let xOffset = this.cvs.width - 55;\n    let yOffset = 70;\n    this.ctx.fillText(`FPS: ${this.fps}`, xOffset, yOffset += 20);\n    this.ctx.fillText(`obj: ${this.particles.length + this.entities.length + this.vanity.length}`, xOffset, yOffset += 20);\n\n    this.ctx.restore();\n  }\n\n  drawUI() {\n    this.ctx.save();\n    this.ctx.font = '20px sans-serif';\n    this.ctx.fillStyle = 'white';\n    this.ctx.shadowBlur = 2;\n    this.ctx.shadowColor = 'black';\n    let xOffset = 10;\n    let yOffset = 2;\n\n    this.ctx.fillText(`Score: ${this.score}`, xOffset, yOffset += 20);\n    this.ctx.fillText(`Highscore: ${this.highscore}`, xOffset, yOffset += 20);\n    this.ctx.fillText(`Time: ${this.timeSeconds}`, xOffset, yOffset += 20);\n    this.ctx.fillText(`Difficulty: ${this.difficulty.toFixed(2)}`, xOffset, yOffset += 20);\n    this.ctx.restore();\n    this.drawFPS();\n  }\n\n  drawVolControls() {\n    this.ctx.save();\n    if (this.mute) {\n      this.ctx.drawImage(MUTE, this.cvs.width - 83, 15, 54, 54);\n    } else {\n      this.ctx.drawImage(VOL, this.cvs.width - 80, 10);\n    }\n    this.ctx.restore();\n  }\n\n  drawHealth() {\n    this.ctx.save();\n    this.ctx.font = '20px sans-serif';\n    let xOffset = this.cvs.width / 2\n    let yOffset = this.cvs.height - 82;\n    // this.ctx.fillStyle = `rgba(${21 + ((this.player.maxHealth - this.player.health) / this.player.maxHealth) * 70},21,21)`;\n    // this.ctx.fillRect(0, 0, this.cvs.width, this.cvs.height);\n    this.ctx.fillStyle = `rgba(${50 - (this.player.health / this.player.maxHealth * 200)},${100 + this.player.health / this.player.maxHealth * 100},0)`;\n    this.ctx.fillRect(xOffset - this.player.health / 2, yOffset, this.player.health, 20);\n    this.ctx.fillStyle = 'white';\n    this.ctx.shadowBlur = 3;\n    this.ctx.shadowColor = 'black';\n    this.ctx.textAlign = 'center';\n    this.ctx.fillText(`${this.player.health}`, xOffset, yOffset + 17);\n    this.ctx.restore();\n  }\n\n  drawChargeBar() {\n    let xOffset = this.cvs.width / 2;\n\n    this.ctx.save();\n    this.ctx.textAlign = 'center';\n    if (this.player.charge >= this.player.chargeMax) {\n\n      this.ctx.fillStyle = this.loopCount % 7 === 0 ? 'white' : \"red\";\n      this.ctx.fillRect(xOffset - this.player.chargeMax * 2, this.cvs.height - 57, this.player.chargeMax * 4, 4);\n      if (this.player.beamCooldown === 0) {\n        this.ctx.font = '12px sans-serif';\n        if (this.player.chargeMax * 2 <= this.player.charge) {\n          this.ctx.fillStyle = this.loopCount % 7 === 0 ? 'white' : \"darkblue\";\n          this.ctx.font = '14px sans-serif';\n          this.vanity.push(new _SlashSpark__WEBPACK_IMPORTED_MODULE_9__[\"default\"](this, xOffset - this.player.chargeMax * 2 + (Math.random() * 2 * this.player.chargeMax) * 2, this.cvs.height - 57, -3, 1, 10));\n          this.ctx.shadowBlur = 2;\n          this.ctx.shadowColor = 'black';\n          this.ctx.fillStyle = this.loopCount % 7 === 0 ? 'darkblue' : 'yellow';\n          this.ctx.fillText(`OVERCHARGE!!`, xOffset, this.cvs.height - 40);\n        } else {\n          this.ctx.shadowBlur = 2;\n          this.ctx.shadowColor = 'black';\n          this.ctx.fillText(`READY!!`, xOffset, this.cvs.height - 40);\n        }\n      }\n      this.ctx.fillStyle = this.loopCount % 7 === 0 ? 'white' : \"darkblue\";\n      let charge = this.player.charge < this.player.chargeMax * 2 ? this.player.charge % this.player.chargeMax : this.player.chargeMax;\n      this.ctx.fillRect(xOffset - charge * 2, this.cvs.height - 59, charge * 4, 6);\n    } else {\n      this.ctx.fillStyle = \"olive\";\n      this.ctx.fillRect(xOffset - this.player.chargeMax * 2, this.cvs.height - 57, this.player.charge * 4, 4);\n      this.ctx.fillRect(xOffset - this.player.chargeMax * 2, this.cvs.height - 58, 2, 6);\n      this.ctx.fillRect(xOffset + this.player.chargeMax * 2, this.cvs.height - 58, 2, 6);\n      if (this.player.beamCooldown === 0) {\n        this.ctx.shadowBlur = 4;\n        this.ctx.shadowColor = 'black';\n\n        this.ctx.fillStyle = \"yellow\";\n        this.ctx.font = '17px sans-serif';\n        this.ctx.clearRect(xOffset - 12, this.cvs.height - 57, 24, 6);\n        this.ctx.fillText(`${this.player.charge}`, xOffset, this.cvs.height - 47);\n        this.ctx.fillStyle = \"olive\";\n        this.ctx.font = '12px sans-serif';\n        this.ctx.fillText(`/${this.player.chargeMax}`, xOffset + 20, this.cvs.height - 41);\n      }\n    }\n    if (this.player.beamCooldown > 0) {\n      this.ctx.fillStyle = this.loopCount % 5 === 0 ? 'white' : \"lightblue\";\n      this.ctx.fillRect(xOffset - this.player.beamCooldown * 2, this.cvs.height - 60, this.player.beamCooldown * 4, 8);\n      this.ctx.font = '13px sans-serif';\n      this.ctx.shadowBlur = 2;\n      this.ctx.shadowColor = 'black';\n      this.ctx.fillText(`!!! COOLDOWN !!!`, xOffset, this.cvs.height - 40);\n    }\n    this.ctx.restore();\n  }\n\n  drawFreeze() {\n    this.ctx.save();\n    this.ctx.fillStyle = `rgba(0,0,0,${this.pauseTime / 10})`;\n    this.ctx.fillRect(0, 0, this.cvs.width, this.cvs.height);\n    this.ctx.restore();\n  }\n\n  draw() {\n    // Resize canvas to window every frame\n    this.ctx.canvas.width = window.innerWidth;\n    this.ctx.canvas.height = window.innerHeight;\n\n    switch (this.state) {\n      case STATE_INIT:\n        break;\n\n      case STATE_BEGIN:\n        this.particles.forEach(entity => entity.draw());\n        // this.player.draw();\n        this.entities.forEach(entity => entity.draw());\n        this.menus.forEach(entity => entity.draw());\n        break;\n\n      case STATE_RUNNING:\n        // Handle drawing of all game objects\n        this.drawFreeze();;\n        this.particles.forEach(entity => entity.draw());\n        this.menus.forEach(entity => entity.draw());\n        this.entities.forEach(entity => entity.draw());\n\n        this.drawChargeBar();\n        this.vanity.forEach(entity => entity.draw());\n        this.player.draw();\n\n        this.drawUI();\n        this.drawHealth();\n        break;\n\n      case STATE_OVER:\n        this.drawFreeze(); \n\n        this.entities.forEach(entity => entity.draw());\n        this.particles.forEach(entity => entity.draw());\n        this.vanity.forEach(entity => entity.draw());\n        this.player.draw();\n        this.menus.forEach(entity => entity.draw());\n        this.drawFPS();\n      break;\n      default:\n        break;\n    }\n    this.drawCursor();\n    this.drawVolControls();\n  }\n\n  loop() {\n    let time = (new Date).getTime();\n    this.timeDelta = time - this.prevTime;\n    \n    if (this.timeDelta < NORMAL_TIME_DELTA * 0.90) {\n\n    } else {\n      if (this.pauseTime > 0) this.pauseTime--;\n      this.prevTime = time;\n      this.update();\n      this.draw();\n      this.fpsCount++;\n    }\n\n    if (time > this.timeTracker) {\n      this.fps = this.fpsCount;\n      this.fpsCount = 0;\n      this.timeTracker += 1000;\n      this.timeSeconds++;\n    }\n    window.requestAnimationFrame(this.loop);\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Game);\n\n//# sourceURL=webpack:///./javascript/Game.js?");

/***/ }),

/***/ "./javascript/GameObject.js":
/*!**********************************!*\
  !*** ./javascript/GameObject.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector */ \"./javascript/Vector.js\");\n\n\n\nconst COLOR = 'black';\nconst RADIUS = 3;\nconst MAX_HEALTH = 100;\n\n\n// May be inefficient to create new position vectors all the time\nclass GameObject {\n  constructor(game) {\n    this.game = game;\n    this.cvs = game.cvs;\n    this.ctx = game.ctx;\n    this.pos = new _Vector__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n    this.vel = new _Vector__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n    this.aim = new _Vector__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n    this.alive = true;\n    this.pauseTime = 0;\n    this.paused = true;\n\n    this.maxHealth = MAX_HEALTH;\n    this.health = MAX_HEALTH;\n\n    this.radius = RADIUS;\n    this.color = COLOR;\n    this.update = this.update.bind(this);\n    this.draw = this.draw.bind(this);\n  }\n\n  validatePosition(rectX, rectY) {\n  }\n\n  update() {\n  }\n\n  // ctx.arc(x, y, r, sAngle, eAngle, [counterclockwise])\n  draw() {\n  }\n  // Multiply velocity by the fractional difference in timeDelta\n  // Does not skip frames, but gives the illusion of same speed\n  addVelocityTimeDelta() {\n    this.pos.add(this.vel.dup().multiply(this.game.timeDelta / this.game.normalTimeDelta));\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (GameObject);\n\n//# sourceURL=webpack:///./javascript/GameObject.js?");

/***/ }),

/***/ "./javascript/Particle.js":
/*!********************************!*\
  !*** ./javascript/Particle.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector */ \"./javascript/Vector.js\");\n/* harmony import */ var _EnemyCircle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EnemyCircle */ \"./javascript/EnemyCircle.js\");\n/* harmony import */ var _GameObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GameObject */ \"./javascript/GameObject.js\");\n\n\n\n\nconst RADIUS = 4;\nconst KNOCKBACK = 10;\nconst DAMAGE = 37;\nconst COLOR = \"#14ffec\";\nconst VELOCITY = 10;\n\nclass Particle extends _GameObject__WEBPACK_IMPORTED_MODULE_2__[\"default\"] {\n  constructor(\n    game, \n    startX = 0, \n    startY = 0, \n    vel = new _Vector__WEBPACK_IMPORTED_MODULE_0__[\"default\"](0,0), \n    cb = () => {} \n  ) {\n    super(game);\n    this.pos = new _Vector__WEBPACK_IMPORTED_MODULE_0__[\"default\"](startX, startY);\n    this.vel = vel || VELOCITY;\n    this.r = RADIUS;\n    this.color = COLOR;\n    this.damage = DAMAGE;\n    this.knockback = KNOCKBACK;\n    this.cb = cb;\n    this.aliveTime = 1;\n\n    this.update = this.update.bind(this);\n    this.draw = this.draw.bind(this);\n  }\n\n  validatePosition(rectX, rectY) {\n    if ( this.pos.x > rectX + this.r \n      || this.pos.x < 0 - this.r \n      || this.pos.y > rectY + this.r \n      || this.pos.y < 0 - this.r ) { \n        this.alive = false;\n      };\n  }\n\n  checkCollision (obj) {\n    if (!obj.alive) return; //Don't check collision if object is not alive\n\n    let diff = _Vector__WEBPACK_IMPORTED_MODULE_0__[\"default\"].difference(this.pos, obj.pos);\n    let distSqr = diff.dot(diff);\n    if (obj instanceof _EnemyCircle__WEBPACK_IMPORTED_MODULE_1__[\"default\"]) {\n      if (this.r * this.r + obj.r * obj.r > distSqr) {\n        this.alive = false;\n        this.vel.normalize();\n        this.vel.multiply(this.knockback / Math.pow(obj.r / 6, 2));\n        obj.vel.add(this.vel);\n        obj.health -= this.damage;\n        if (obj.health <= 0) obj.alive = false;\n      }\n    }\n  }\n\n  update() {\n    if (!this.alive) return; //Don't check collision if object is not alive\n    this.cb();\n    this.addVelocityTimeDelta();\n    this.game.entities.forEach(entity => { this.checkCollision(entity) });\n    this.validatePosition(this.cvs.width, this.cvs.height);\n  }\n\n  // ctx.arc(x, y, r, sAngle, eAngle, [counterclockwise])\n  draw() {\n    this.ctx.save();\n    this.ctx.beginPath();\n    this.ctx.arc(this.pos.x, this.pos.y, this.r, 0, 2 * Math.PI);\n    this.ctx.fillStyle = this.color;\n    this.ctx.fill();\n    // this.ctx.strokeStyle = this.color;\n    // this.ctx.stroke();\n\n    this.ctx.closePath();\n    this.ctx.restore();\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Particle);\n\n//# sourceURL=webpack:///./javascript/Particle.js?");

/***/ }),

/***/ "./javascript/Player.js":
/*!******************************!*\
  !*** ./javascript/Player.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector */ \"./javascript/Vector.js\");\n/* harmony import */ var _GameObject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GameObject */ \"./javascript/GameObject.js\");\n/* harmony import */ var _enemy_factory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./enemy_factory */ \"./javascript/enemy_factory.js\");\n/* harmony import */ var _particle_factory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./particle_factory */ \"./javascript/particle_factory.js\");\n/* harmony import */ var _Slam__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Slam */ \"./javascript/Slam.js\");\n/* harmony import */ var _BeamSlash__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./BeamSlash */ \"./javascript/BeamSlash.js\");\n/* harmony import */ var _Beam__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Beam */ \"./javascript/Beam.js\");\n/* harmony import */ var _Explosion__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Explosion */ \"./javascript/Explosion.js\");\n/* harmony import */ var _SlashSpark__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./SlashSpark */ \"./javascript/SlashSpark.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n// import shotSfx from '../assets/laser7.wav';\n\nconst CLAMP_SPAWN = 100; // Offset from edges\nconst MAX_SPEED = 7;\nconst MIN_SPEED = 0.1;\nconst ACCEL = 3;\nconst DECEL = 0.9;\nconst SPRINT_SPEED = 8;\nconst MAX_SPRINT_SPEED = 10;\nconst DASH_TIME = 0;\nconst DASH_SPEED = 7;\nconst DASH_COOLDOWN = 13;\nconst POST_DASH_INVUL = 2;\nconst CHARGE_MAX = 60;\n// const CHARGE_MAX = 0;\nconst CHARGE_STACKS = 2.2;\nconst CHARGE_COOLDOWN = 90;\n// const CHARGE_COOLDOWN = 10;\nconst SHOOT_COOLDOWN = 0;\n\nconst PLAYER_RADIUS = 11;\nconst COLOR = '#0d7377';\nconst DAMPENING_COEFFICIENT = 0.7;\nconst CLAMP_SPEED = 200;\n\n\nconst STATE_WALKING = \"STATE_WALKING\";\nconst STATE_DASHING = \"STATE_DASHING\";\n\nconst KEY = {\n  W: 87,\n  A: 65,\n  S: 83,\n  D: 68,\n  ENTER: 13,\n  UP: 38,\n  // LEFT: 37,\n  DOWN: 40,\n  // RIGHT: 39,\n  SHIFT: 16,\n  SPACE: 32,\n  MOUSE_LEFT: 10000,\n  MOUSE_RIGHT: 10002,\n};\n\nconst MOUSE = {\n  LEFT: 0,\n  MIDDLE: 1,\n  RIGHT: 2,\n}\n\nclass Player extends _GameObject__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\n  constructor(game) {\n    super(game);\n    \n    this.pos = new _Vector__WEBPACK_IMPORTED_MODULE_0__[\"default\"](CLAMP_SPAWN + Math.random() * (this.cvs.width - CLAMP_SPAWN * 2),\n                          CLAMP_SPAWN + Math.random() * (this.cvs.height - CLAMP_SPAWN * 2));\n    this.vel = new _Vector__WEBPACK_IMPORTED_MODULE_0__[\"default\"](); \n    this.aim = new _Vector__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n    this.mousePos = new _Vector__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this.cvs.width / 2, this.cvs.height / 2);\n    this.shootCooldown = 0;\n    this.slashReset = 0;\n    this.slashCombo = 0;\n    this.moveState = STATE_WALKING;\n    this.dashDuration = 0;\n    this.dashDirection = new _Vector__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n    this.dashCooldown = 0;\n    this.beamCooldown = 0;\n    this.invul = 0;\n    this.noclip = 0;\n    this.velRestoreDash = new _Vector__WEBPACK_IMPORTED_MODULE_0__[\"default\"](); \n    this.charge = CHARGE_MAX;\n    this.chargeMax = CHARGE_MAX;\n\n    this.maxHealth = 100;\n    this.health = this.maxHealth;\n\n    this.r = PLAYER_RADIUS;\n    this.color = COLOR;\n    this.keyDown = {\n      [KEY.W]: false,\n      [KEY.A]: false,\n      [KEY.S]: false,\n      [KEY.D]: false,\n      [KEY.SHIFT]: false,\n      [KEY.SPACE]: false,\n      [KEY.MOUSE_LEFT]: false,\n      [KEY.MOUSE_RIGHT]: false,\n    }\n\n    this.setMousePosition = this.setMousePosition.bind(this);\n    this.update = this.update.bind(this);\n    this.draw = this.draw.bind(this);\n  }\n\n  // Store mouse position relative to canvas origin\n  setMousePosition(e) {\n    var canvasRect = this.cvs.getBoundingClientRect();\n    this.mousePos.x = e.clientX - canvasRect.left;\n    this.mousePos.y = e.clientY - canvasRect.top;\n    this.setAim();\n  }\n\n  // Set player's unnormalized aim relative to stored mouse position\n  setAim() {\n    this.aim = new _Vector__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this.mousePos.x - this.pos.x, this.mousePos.y - this.pos.y);\n  }\n\n  // Dash in a direction for a few frames\n  // End dash logic is handled in update\n  dash() {\n    if (this.moveState !== STATE_DASHING) {\n      this.moveState = STATE_DASHING;\n      // this.pauseTime = 3;\n      this.invul = 5;\n\n      this.setAim();\n      // this.vel = this.aim.dup().normalize().multiply(DASH_SPEED * 2);\n      // this.velRestoreDash = this.vel.dup();\n      this.dashDirection = this.aim.dup();\n      this.dashDuration = DASH_TIME;\n      this.game.playSoundMany(`${this.game.filePath}/assets/SE_00064.wav`, 0.13);\n    }\n  }\n\n  fireBeam() {\n    if (this.charge >= CHARGE_MAX) {\n      let beam = new _Beam__WEBPACK_IMPORTED_MODULE_6__[\"default\"](this.game, this.pos.x, this.pos.y);\n      beam.width = 300;\n      beam.length = 3000;\n      beam.damage = 3500;\n      beam.knockback = 40;\n      beam.color = \"red\";\n      beam.combo = -2;\n      this.charge -= CHARGE_MAX;\n      this.beamCooldown = CHARGE_COOLDOWN;\n      this.game.delayedParticles.push(beam);\n      let freezeTime = 18;\n      this.game.freeze(freezeTime);\n      this.invul = 5;\n      let kb = this.aim.dup().normalize().multiply(-75);\n      this.vel.add(kb);\n\n      let cb = function() {\n        this.length *= 0.70;\n        this.width *= 0.70;\n      }\n      let baseAngle = Math.floor(Math.random() * 360) * Math.PI / 180;\n      let spark1 = new _SlashSpark__WEBPACK_IMPORTED_MODULE_8__[\"default\"](this.game, this.pos.x, this.pos.y, 0, 70, 2000, 30, baseAngle, Math.PI / 20, false);\n      let spark2 = new _SlashSpark__WEBPACK_IMPORTED_MODULE_8__[\"default\"](this.game, this.pos.x, this.pos.y, 0, 70, 2000, 30, baseAngle + Math.PI / 2, Math.PI / 20, false);\n      spark1.cb = cb;\n      spark2.cb = cb;\n      this.game.vanity.push(spark1);\n      this.game.vanity.push(spark2);\n\n      let explosion1 = new _Explosion__WEBPACK_IMPORTED_MODULE_7__[\"default\"](this.game, this.pos.x, this.pos.y, 100);\n      explosion1.aliveTime = 7;\n      explosion1.color = \"rgba(255,255,255,.1)\";\n      this.game.vanity.push(explosion1);\n\n      let explosion2 = new _Explosion__WEBPACK_IMPORTED_MODULE_7__[\"default\"](this.game, this.pos.x, this.pos.y, 150);\n      explosion2.aliveTime = 5;\n      this.game.vanity.push(explosion2);\n\n      this.game.playSoundMany(`${this.game.filePath}/assets/SE_00016.wav`, 0.2);\n\n      setTimeout(function() {\n        this.game.playSoundMany(`${this.game.filePath}/assets/SE_00049.wav`, 0.4);\n      }, this.game.normalTimeDelta * freezeTime);\n    }\n  }\n\n  // Fire\n  shoot() {\n    if (this.game.loopCount % 5 === 0) {\n      this.game.playSoundMany(`${this.game.filePath}/assets/laser7.wav`, 0.2);\n    }\n\n    this.shootCooldown = SHOOT_COOLDOWN;\n    Object(_particle_factory__WEBPACK_IMPORTED_MODULE_3__[\"fireBulletAtCursor\"])(this);\n    Object(_particle_factory__WEBPACK_IMPORTED_MODULE_3__[\"fireBulletAtCursor\"])(this);\n    Object(_particle_factory__WEBPACK_IMPORTED_MODULE_3__[\"fireBulletAtCursor\"])(this);\n    Object(_particle_factory__WEBPACK_IMPORTED_MODULE_3__[\"fireBulletAtCursor\"])(this);\n  }\n\n\n  mountController() {\n    document.addEventListener('keydown', (e) => {\n      let key = e.keyCode;\n      if(key === 8) this.health = 0; // BACKSPACE\n      if(key === 187) this.game.difficulty++; //EQUAL\n      if(key === 189) this.health += 100; //MINUS\n\n      // Ignore keys that have not been bound\n      if (!Object.values(KEY).includes(key)) return;\n      switch (this.game.state) {\n        case this.game.STATE_INIT:\n          break;\n        case this.game.STATE_BEGIN:\n          if (key !== KEY.ENTER && key !== KEY.SPACE) { \n            this.keyDown[key] = true;\n            this.game.startGame();\n          }\n          break;\n        case this.game.STATE_RUNNING:\n          this.keyDown[key] = true;\n          if (key == KEY.DOWN) this.game.entities.push(_enemy_factory__WEBPACK_IMPORTED_MODULE_2__[\"spawnCircleRandom\"](this));\n          if (key == KEY.UP) this.charge += CHARGE_MAX;\n          break;\n        case this.game.STATE_OVER:\n          if (key === KEY.ENTER) this.game.restartGame();\n          break;\n        default:\n          break;\n      }\n    });\n\n    document.addEventListener('keyup', (e) => {\n      let key = e.keyCode;\n      if (!Object.values(KEY).includes(key)) return;\n      switch (this.game.state) {\n        case this.game.STATE_INIT:\n          break;\n        case this.game.STATE_BEGIN:\n          break;\n        case this.game.STATE_RUNNING:\n          this.keyDown[key] = false;\n          break;\n        case this.game.STATE_OVER:\n          break;\n        default:\n          break;\n      }\n    });\n\n    document.onmousemove = (e) => {\n      this.setMousePosition(e);\n    };\n\n    // Disable right click context menu\n    document.addEventListener(\"contextmenu\", (e) => { \n      e.preventDefault();\n      return false;\n    });\n\n    document.addEventListener(\"mousedown\", (e) => {\n      e.preventDefault();\n      let clickType = e.button;\n\n      switch (this.game.state) {\n        case this.game.STATE_INIT:\n          break;\n        case this.game.STATE_BEGIN:\n          this.game.startGame();\n          if (clickType === MOUSE.LEFT) this.keyDown[KEY.MOUSE_LEFT] = true;\n          if (clickType === MOUSE.RIGHT) this.keyDown[KEY.MOUSE_RIGHT] = true;\n          break;\n        case this.game.STATE_RUNNING:\n          if (clickType === MOUSE.LEFT) this.keyDown[KEY.MOUSE_LEFT] = true;\n          if (clickType === MOUSE.RIGHT) this.keyDown[KEY.MOUSE_RIGHT] = true;\n          break;\n        case this.game.STATE_OVER:\n          break;\n        default:\n          break;\n      }\n\n      if (\n        this.mousePos.x >= this.cvs.width - 100 &&\n        this.mousePos.x <= this.cvs.width  &&\n        this.mousePos.y >= 0  &&\n        this.mousePos.y <= 100 ) {\n          this.game.mute = !this.game.mute;\n          if (this.game.bgm.volume === 0) {\n            this.game.bgm.volume = 0.4;\n            this.game.bgm.play();\n          } else {\n            this.game.bgm.volume = 0;\n            this.game.bgm.pause();\n          }\n        }\n    });\n\n    document.addEventListener(\"mouseup\", (e) => {\n      e.preventDefault();\n      let clickType = e.button;\n\n      switch (this.game.state) {\n        case this.game.STATE_INIT:\n          break;\n        case this.game.STATE_BEGIN:\n          this.game.startGame();\n          break;\n        case this.game.STATE_RUNNING:\n          if (clickType === MOUSE.LEFT) this.keyDown[KEY.MOUSE_LEFT] = false;\n          if (clickType === MOUSE.RIGHT) this.keyDown[KEY.MOUSE_RIGHT] = false;\n          break;\n        case this.game.STATE_OVER:\n          break;\n        default:\n          break;\n      }\n    });\n  }\n\n  // Ensure players do not leave the boundaries defined here.\n  validatePosition(rectX, rectY) {\n    if(this.pos.x + this.r > rectX) this.pos.x = rectX - this.r;\n    if(this.pos.x - this.r < 0) this.pos.x = this.r;\n    if(this.pos.y + this.r > rectY) this.pos.y = rectY - this.r;\n    if(this.pos.y - this.r < 0) this.pos.y = this.r;\n  }\n\n  dampSpeed() {\n    let vel = this.vel.length();\n    let maxSpeed = (this.keyDown[KEY.SHIFT] \n      ? MAX_SPRINT_SPEED \n      : MAX_SPEED)\n    if(vel > CLAMP_SPEED) {\n      this.vel.normalize().multiply(CLAMP_SPEED);\n    }\n    if(vel > maxSpeed) {\n      this.vel.multiply(DAMPENING_COEFFICIENT);\n    }\n  }\n\n  applyDecel() {\n    if(this.keyDown[KEY.W]) return;\n    if(this.keyDown[KEY.A]) return;\n    if(this.keyDown[KEY.S]) return;\n    if(this.keyDown[KEY.D]) return;\n    let result = this.vel.multiply(DECEL);\n    if (result.x < MIN_SPEED || result.x > -1 * MIN_SPEED) result.x = 0; \n    if (result.y < MIN_SPEED || result.y > -1 * MIN_SPEED) result.y = 0; \n    this.vel = result;\n  }\n\n  update() {\n    // if player is dead, simplify update loop\n    if (!this.alive) {\n      this.dampSpeed();\n      this.addVelocityTimeDelta();\n      this.applyDecel();\n      this.validatePosition(this.cvs.width, this.cvs.height);\n      return;\n    }\n\n    if (this.shootCooldown > 0) this.shootCooldown--;\n    if (this.dashCooldown > 0) this.dashCooldown--;\n    if (this.beamCooldown > 0) this.beamCooldown--;\n    if (this.invul >= 0) this.invul--;\n    if (this.noclip >= 0) this.noclip--;\n    if (this.charge > CHARGE_MAX * CHARGE_STACKS) this.charge = Math.floor(CHARGE_MAX * CHARGE_STACKS);\n\n    // handle combo reset logic\n    if (this.slashReset > 0) {\n      this.slashReset--;\n    } else {\n      this.slashCombo = 0;\n    }\n\n    // add sparks for charge level\n    if (this.game.loopCount % 2) {\n      if (this.charge >= this.chargeMax * 2) {\n        this.game.vanity.push(new _SlashSpark__WEBPACK_IMPORTED_MODULE_8__[\"default\"](this.game, this.pos.x, this.pos.y, -1, 3, this.r * 2));\n      } else if (this.charge >= this.chargeMax) {\n        this.game.vanity.push(new _SlashSpark__WEBPACK_IMPORTED_MODULE_8__[\"default\"](this.game, this.pos.x, this.pos.y, -3, 2, this.r * 1.5));\n      }\n    }\n    \n    // if player is paused, do not apply movement or actions\n    if (this.pauseTime > 0) {\n      this.pauseTime--;\n      if(this.pauseTime === 0) {\n        // this.vel = this.velRestoreDash;\n      } else {\n        return;\n      }\n    }\n\n    // Calculate facing direction and apply shooting controls\n    this.setAim();\n\n    if (this.keyDown[KEY.MOUSE_LEFT] && this.dashCooldown <= 0) this.dash();\n    if (this.keyDown[KEY.MOUSE_RIGHT] && this.shootCooldown <= 0) this.shoot();\n    if (this.keyDown[KEY.SPACE] && this.beamCooldown <= 0) this.fireBeam();\n\n    // Apply movement\n    if (this.moveState === STATE_WALKING) {\n      let offset = ACCEL * (this.keyDown[KEY.SHIFT] ? SPRINT_SPEED : 1);\n      if (this.vel.length() < MAX_SPRINT_SPEED) {\n        if (this.keyDown[KEY.W]) this.vel.y -= offset;\n        if (this.keyDown[KEY.A]) this.vel.x -= offset;\n        if (this.keyDown[KEY.S]) this.vel.y += offset;\n        if (this.keyDown[KEY.D]) this.vel.x += offset;\n      }\n\n      this.dampSpeed();\n      this.addVelocityTimeDelta();\n      this.applyDecel();\n    } else if (this.moveState === STATE_DASHING) {\n      // dash has ended\n      if (this.dashDuration <= 0) {\n        this.invul = POST_DASH_INVUL;\n        this.moveState = STATE_WALKING;\n        // this.game.particles.push(new Slam(this.game, this.pos.x, this.pos.y));\n        \n        this.game.particles.push(new _BeamSlash__WEBPACK_IMPORTED_MODULE_5__[\"default\"](this.game, this.slashCombo));\n        if (this.slashCombo === 3) {\n          this.dashCooldown = DASH_COOLDOWN + 60;\n          this.slashCombo = 0;\n          this.shootCooldown = this.dashCooldown - 30;\n          this.invul += 30;\n          this.noclip += 30;\n          // this.pauseTime = 5;\n        } else {\n          this.dashCooldown = DASH_COOLDOWN;\n          this.shootCooldown = this.dashCooldown + 5;\n          this.slashCombo++;\n          this.slashReset = DASH_COOLDOWN * 1.6;\n        }\n      } else {\n        this.dashDuration--;\n        this.vel.add(this.aim.normalize().multiply(DASH_SPEED));\n\n        this.addVelocityTimeDelta();\n      }\n    } \n\n    this.validatePosition(this.cvs.width, this.cvs.height);\n  }\n\n  // ctx.arc(x, y, r, sAngle, eAngle, [counterclockwise])\n  draw() {\n    this.ctx.save();\n    this.ctx.beginPath();\n    this.ctx.arc(this.pos.x, this.pos.y, this.r, 0, 2 * Math.PI);\n    this.ctx.fillStyle = this.color;\n    this.ctx.strokeStyle = \"white\";\n\n    this.ctx.shadowBlur = 6;\n    this.ctx.shadowColor = \"white\";\n    \n    this.ctx.fill();\n    this.ctx.stroke();\n    this.ctx.closePath();\n\n    this.ctx.restore();\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Player);\n\n//# sourceURL=webpack:///./javascript/Player.js?");

/***/ }),

/***/ "./javascript/Slam.js":
/*!****************************!*\
  !*** ./javascript/Slam.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector */ \"./javascript/Vector.js\");\n/* harmony import */ var _EnemyCircle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EnemyCircle */ \"./javascript/EnemyCircle.js\");\n/* harmony import */ var _Particle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Particle */ \"./javascript/Particle.js\");\n\n\n\n\nconst RADIUS = 100;\nconst KNOCKBACK = 150;\nconst DAMAGE = 70;\nconst GROWTH_RATE = 10;\n// const COLOR = \"white\";\n\nclass Slam extends _Particle__WEBPACK_IMPORTED_MODULE_2__[\"default\"] {\n  constructor(game, startX, startY) {\n    super(game);\n    this.pos = new _Vector__WEBPACK_IMPORTED_MODULE_0__[\"default\"](startX, startY);\n    this.vel = new _Vector__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n    this.r = RADIUS;\n    this.color = this.game.player.color;\n    this.damage = DAMAGE;\n    this.knockback = KNOCKBACK;\n    this.aliveTime = 10;\n    this.initialTime= this.aliveTime;\n    this.growthRate = GROWTH_RATE;\n\n    // this.update = this.update.bind(this);\n    // this.draw = this.draw.bind(this);\n  }\n\n\n  checkCollision(obj) {\n    if (!obj.alive) return; //Don't check collision if object is not alive\n\n    let diff = _Vector__WEBPACK_IMPORTED_MODULE_0__[\"default\"].difference(this.pos, obj.pos);\n    let distSqr = diff.dot(diff);\n    if (obj instanceof _EnemyCircle__WEBPACK_IMPORTED_MODULE_1__[\"default\"]) {\n      if (this.r * this.r + obj.r * obj.r > distSqr) {\n        diff.normalize();\n        obj.vel.add(diff.multiply(this.knockback));\n        obj.health -= this.damage;\n        if (obj.health <= 0) obj.alive = false;\n      }\n    }\n  }\n\n  update() {\n    if (!this.alive) return; //Don't check collision if object is not alive\n    \n    if(this.aliveTime === this.initialTime) {\n      this.game.entities.forEach(entity => { this.checkCollision(entity) });\n      this.game.freeze(5);\n    }\n    if (this.aliveTime <= 0) {\n      this.alive = false;\n    }\n    this.aliveTime--;\n    this.cb();\n  }\n\n  // ctx.arc(x, y, r, sAngle, eAngle, [counterclockwise])\n  draw() {\n    if (this.aliveTime > this.initialTime - 5) {\n      this.ctx.save();\n\n      this.ctx.beginPath();\n      this.ctx.arc(this.pos.x, this.pos.y, this.r, 0, 2 * Math.PI);\n      this.ctx.fillStyle = this.color;\n      this.ctx.fill(); \n      this.ctx.strokeStyle = \"white\";\n      this.ctx.stroke(); \n      this.ctx.restore();\n    } else {\n      this.ctx.save();\n\n      this.r += this.growthRate;\n      this.ctx.beginPath();\n      this.ctx.arc(this.pos.x, this.pos.y, this.r, 0, 2 * Math.PI);\n      this.ctx.fillStyle = \"rgba(0,0,0,0)\";\n      this.ctx.fill();\n      this.ctx.strokeStyle = \"white\";\n     \n      this.ctx.shadowBlur = 30;\n      this.ctx.shadowColor = this.color;\n      this.ctx.stroke();  \n\n      this.ctx.restore();\n  \n    }\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Slam);\n\n//# sourceURL=webpack:///./javascript/Slam.js?");

/***/ }),

/***/ "./javascript/SlashSpark.js":
/*!**********************************!*\
  !*** ./javascript/SlashSpark.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector */ \"./javascript/Vector.js\");\n/* harmony import */ var _Particle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Particle */ \"./javascript/Particle.js\");\n\n\n\n\nconst WIDTH = 1;\nconst LENGTH = 60;\n\nconst DURATION = 20;\n\nconst COLOR = {\n  NORMAL: [255, 255, 255],\n  CRIT: [255, 255, 0],\n  CANNON: [0, 0, 0],\n}\n//\n// hitspark for beams\n//\nclass SlashSpark extends _Particle__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\n  constructor(game, x, y, \n      combo = 0, \n      width = WIDTH, \n      length = LENGTH, \n      duration = DURATION, \n      angle = Math.floor(Math.random() * 360) * Math.PI / 180, \n      rotation = 0, \n      pauseState = true) {\n    super(game);\n    this.pos = new _Vector__WEBPACK_IMPORTED_MODULE_0__[\"default\"](x, y);\n    this.combo = combo;\n    this.width = width;\n    this.length = length;\n    this.aliveTime = duration;\n    this.initialTime = this.aliveTime;\n    this.rotation = rotation;\n    this.paused = pauseState;\n    this.cb = () => {};\n\n    this.offsets = [];\n    this.offsets.push(-Math.PI / 32 + Math.random() * Math.PI / 16);\n    this.offsets.push(-Math.PI / 32 + Math.random() * Math.PI / 16);\n    this.offsets.push(-Math.PI / 32 + Math.random() * Math.PI / 16);\n    this.offsets.push(-Math.PI / 32 + Math.random() * Math.PI / 16);\n    this.offsets.push(-Math.PI / 32 + Math.random() * Math.PI / 16);\n\n    // this.angle = Math.atan2(this.aim.y, this.aim.x);\n\n    this.angle = angle;\n    // let newAim = new Vector(1, 0);\n    // newAim.multiply(1, -1);\n\n    // let x2 = newAim.x * Math.cos(angle) - newAim.y * Math.sin(angle);\n    // let y2 = newAim.y * Math.cos(angle) + newAim.x * Math.sin(angle);\n    // // debugger\n    // this.aim = new Vector(-x2, -y2);\n\n    switch(this.combo) {\n      case -1:\n        this.color = COLOR.CRIT;\n        break;\n      case -2:\n        // this.angle = (Math.atan2(this.aim.y, this.aim.x));\n        this.color = COLOR.CANNON;\n        break;\n      case -3:\n        this.color = COLOR.CRIT;\n        break;\n      case 3:\n        this.color = COLOR.CRIT;\n        break;\n      default:\n        this.color = COLOR.NORMAL;\n        break;\n    }\n  }\n\n  checkCollision(obj) {\n    // SlashSpark does not check collision\n  }\n\n  drawRect(offset, colorIn, widthMod = 1, lengthMod = 1) {\n    \n    this.ctx.save();\n\n    let percent = this.aliveTime / this.initialTime;\n    let color;\n    if (this.combo === -1) {\n      this.aliveTime >= this.initialTime - 2 \n        ? color = `rgba(${colorIn[0]},${colorIn[1]},${colorIn[2]},${1})` \n        : color = `rgba(${colorIn[0]},${colorIn[1]},${colorIn[2]},${percent})`\n    } else if (this.combo === -2) {\n      this.aliveTime >= this.initialTime - 2 \n        ? color = `rgba(255,255,255,${1})`\n        : color = `rgba(${this.color[0]},${this.color[1]},${this.color[2]},${percent})`\n    } else {\n      this.aliveTime >= this.initialTime - 1\n        ? color = `rgba(${this.color[0]},${this.color[1]},${this.color[2]},${percent})`\n        : color = `rgba(${this.color[0]},${this.color[1]},${this.color[2]},${percent - 0.3})`\n    }\n    this.ctx.fillStyle = color;\n    this.ctx.strokeStyle = color;\n    // Offset the rect based on its width but maintain origin\n    this.ctx.translate(this.pos.x + Math.sin(this.angle + offset) * widthMod * this.width / 2,\n                       this.pos.y - Math.cos(this.angle + offset) * widthMod * this.width / 2);\n    this.ctx.rotate(this.angle + offset);\n    this.ctx.fillRect(0, 0, this.length * lengthMod, widthMod * this.width);\n    this.ctx.restore();\n  }\n\n  update() {\n    this.angle += this.rotation;\n    // transient effect\n    this.width *= 0.85;\n    switch(this.combo) {\n      case -1:\n        this.length *= 1.005;\n        break;\n      case -2:\n        this.length *= 0.95;\n        break;\n      default:\n      // this will alias the edges\n        this.length *= 1.001;\n        break;\n    }\n\n    if (this.aliveTime <= 0) {\n      this.alive = false;\n    }\n    this.aliveTime--;\n    this.cb();\n\n  }\n\n  draw() {\n    let color = [Math.random() * 255, Math.random() * 255, Math.random() * 255];\n    if (this.combo === -2) {\n      if (this.aliveTime >= this.initialTime - 10) {\n        color = [255, 255, 255]\n      } else {\n        color = [0, 0, 0]\n      }\n      this.drawRect(0, color, 1    , 1.5);\n      this.drawRect(0, color, 3 / 4, 1.55);\n      this.drawRect(0, color, 1 / 3, 1.58);\n      // this.drawRect(this.offsets[1]);\n    } else {\n\n      this.drawRect(0, color);\n      this.drawRect(Math.PI, color);\n    }\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (SlashSpark);\n\n//# sourceURL=webpack:///./javascript/SlashSpark.js?");

/***/ }),

/***/ "./javascript/Vector.js":
/*!******************************!*\
  !*** ./javascript/Vector.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n\nclass Vector {\n  constructor(x = 0, y = 0) {\n    this.x = x;\n    this.y = y;\n  }\n\n  add(v) {\n    if (v instanceof Vector) {\n      this.x += v.x;\n      this.y += v.y;\n    } else {\n      this.x += v; \n      this.y += v; \n    }\n    return this;\n  }\n\n  subtract(v) {\n    if (v instanceof Vector) {\n      this.x -= v.x;\n      this.y -= v.y;\n    } else {\n      this.x -= v; \n      this.y -= v; \n    }\n    return this;\n  }\n\n  multiply(v) {\n    if (v instanceof Vector) {\n      this.x *= v.x;\n      this.y *= v.y;\n    } else {\n      this.x *= v; \n      this.y *= v; \n    }\n    return this;\n  }\n  \n  divide(v) {\n    if (v instanceof Vector) {\n      if(v.x !== 0) this.x /= v.x;\n      if(v.y !== 0) this.y /= v.y;\n    } else {\n      if(v !== 0) {\n        this.x /= v; \n        this.y /= v; \n      }\n    }\n    return this;\n  }\n\n  dup() {\n    return new Vector(this.x, this.y);\n  }\n  \n  invert() {\n    this.x *= -1;\n    this.y *= -1;\n    return this;\n  }\n\n  static difference(v1, v2) {\n    let newV = new Vector(1, 1).multiply(v1);\n    return newV.subtract(v2);\n  }\n\n  equals(v) {\n    return this.x === v.x && this.y === v.y;\n  }\n\n  dot(v) {\n    return this.x * v.x + this.y * v.y;\n  }\n\n  length() {\n    return Math.sqrt(this.dot(this));\n  }\n\n  // WARNING - operation calls divide which will modify this vector\n  normalize() {\n    // let that = new Vector(this.x, this.y);\n    // return that.divide(this.length());\n    return this.divide(this.length());\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Vector);\n\n//# sourceURL=webpack:///./javascript/Vector.js?");

/***/ }),

/***/ "./javascript/enemy_factory.js":
/*!*************************************!*\
  !*** ./javascript/enemy_factory.js ***!
  \*************************************/
/*! exports provided: randomEdgePos, spawnCircleRandom */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"randomEdgePos\", function() { return randomEdgePos; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"spawnCircleRandom\", function() { return spawnCircleRandom; });\n/* harmony import */ var _Vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector */ \"./javascript/Vector.js\");\n/* harmony import */ var _EnemyCircle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EnemyCircle */ \"./javascript/EnemyCircle.js\");\n\n\n\n\nconst MAP = {\n  TOP: 0,\n  LEFT: 1,\n  BOTTOM: 2,\n  RIGHT: 3,\n}\n\n// const SPAWN_OFFSET = 20;\nconst BASE_TURN_RATE = 0.25;\n\nconst randomEdgePos = (canvas, radius) => {\n  let side = Math.floor(Math.random() * 4);\n\n  let pos = { x: Math.random() * canvas.width,\n              y: Math.random() * canvas.height };\n\n  switch(side) {\n    case MAP.TOP:\n      pos.y = -radius;\n      break;\n    case MAP.LEFT:\n      pos.x = -radius;\n      break;\n    case MAP.BOTTOM:\n      pos.y = canvas.height + radius;\n      break;\n    case MAP.RIGHT:\n      pos.x = canvas.width + radius;\n      break;\n  }\n\n  return pos;\n}\n\nconst makeBoss = function(enemy) {\n  if (Math.floor(Math.random() * 1000) % 50 === 0) {\n    enemy.r = Math.floor(50 + Math.random() * 50);\n    if (enemy.game.state === \"STATE_OVER\") enemy.r *= 1 + Math.random() * 4;\n    if (Math.floor(Math.random() * 5) % 3 === 0) {\n      enemy.accel = 0.5 + Math.random() * Math.pow(enemy.game.difficulty, 1 / 2);\n      enemy.maxSpeed = 1.5 + Math.random() * Math.pow(enemy.game.difficulty, 1 / 2);\n    } else {\n      enemy.accel = 0.2;\n      enemy.maxSpeed = 0.5;\n    }\n    enemy.health = 13000;\n    enemy.damage = 50;\n    enemy.score = enemy.r * 2;\n  }\n}\n\nconst spawnCircleRandom = (player) => {\n  let enemy = new _EnemyCircle__WEBPACK_IMPORTED_MODULE_1__[\"default\"](player.game);  \n\n  enemy.accel = 0.5 + Math.random() * Math.pow(player.game.difficulty, 1 / 2);\n  enemy.maxSpeed = 1.5 + Math.random() * Math.pow(player.game.difficulty, 1 / 2);\n\n  makeBoss(enemy);\n  \n  let spawnPos = randomEdgePos(player.cvs, enemy.r);\n  enemy.pos.x = spawnPos.x;\n  enemy.pos.y = spawnPos.y;\n  \n  enemy.aiCallback = function() {\n    this.aim = _Vector__WEBPACK_IMPORTED_MODULE_0__[\"default\"].difference(player.pos, this.pos).normalize();\n    let turnRate = BASE_TURN_RATE + Math.pow(player.game.difficulty, 1/2);\n    this.aim.multiply(turnRate).add(this.vel).normalize();\n\n    this.vel.add(this.aim.multiply(this.accel));\n  };\n\n  return enemy;\n}\n\n\n\n//# sourceURL=webpack:///./javascript/enemy_factory.js?");

/***/ }),

/***/ "./javascript/main.js":
/*!****************************!*\
  !*** ./javascript/main.js ***!
  \****************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Game__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Game */ \"./javascript/Game.js\");\n\n\n\nwindow.addEventListener(\"DOMContentLoaded\", () => {\n  const cvs = document.getElementById('ball-popcalypse');\n  const ctx = cvs.getContext('2d');\n  const game = new _Game__WEBPACK_IMPORTED_MODULE_0__[\"default\"](cvs, ctx);\n  window.game = game;\n  \n  game.loop();\n});\n\n//# sourceURL=webpack:///./javascript/main.js?");

/***/ }),

/***/ "./javascript/particle_factory.js":
/*!****************************************!*\
  !*** ./javascript/particle_factory.js ***!
  \****************************************/
/*! exports provided: fireBulletAtCursor, fireBulletAtCursorB, fireBeamAtCursor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fireBulletAtCursor\", function() { return fireBulletAtCursor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fireBulletAtCursorB\", function() { return fireBulletAtCursorB; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fireBeamAtCursor\", function() { return fireBeamAtCursor; });\n/* harmony import */ var _Particle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Particle */ \"./javascript/Particle.js\");\n/* harmony import */ var _Beam__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Beam */ \"./javascript/Beam.js\");\n/* harmony import */ var _Vector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Vector */ \"./javascript/Vector.js\");\n\n\n\n\n\nconst BULLET_SPEED = 20;\nconst BULLET_SPREAD = 0.12;\n\nconst fireBulletAtCursor = (player) => {\n  let p = new _Particle__WEBPACK_IMPORTED_MODULE_0__[\"default\"](player.game);\n  p.pos.x = player.pos.x;\n  p.pos.y = player.pos.y;\n  p.color = \"#14ffec\";\n\n  let aim = new _Vector__WEBPACK_IMPORTED_MODULE_2__[\"default\"](1, 1);\n  aim.multiply(player.aim);\n  aim.normalize();\n  aim.x += Math.random() * (BULLET_SPREAD + BULLET_SPREAD) - BULLET_SPREAD;\n  aim.y += Math.random() * (BULLET_SPREAD + BULLET_SPREAD) - BULLET_SPREAD;\n  aim.normalize();\n  p.vel = aim.multiply(BULLET_SPEED * (1 - BULLET_SPREAD ) + BULLET_SPREAD / 2 + Math.random() * BULLET_SPREAD);\n  player.game.particles.push(p);\n}\n\nconst fireBulletAtCursorB = (player) => {\n  let p = new _Particle__WEBPACK_IMPORTED_MODULE_0__[\"default\"](player.game);\n  p.pos.x = player.pos.x;\n  p.pos.y = player.pos.y;\n  p.color = 'orange';\n\n  let aim = new _Vector__WEBPACK_IMPORTED_MODULE_2__[\"default\"](1, 1);\n  aim.multiply(player.aim);\n  aim.normalize();\n  aim.x += Math.random() * (BULLET_SPREAD + BULLET_SPREAD) - BULLET_SPREAD;\n  aim.y += Math.random() * (BULLET_SPREAD + BULLET_SPREAD) - BULLET_SPREAD;\n  aim.normalize();\n  p.vel = aim.multiply(BULLET_SPEED);\n  return p;\n}\n\nconst fireBeamAtCursor = (player) => {\n  let p = new _Beam__WEBPACK_IMPORTED_MODULE_1__[\"default\"](player.game, player.pos.x, player.pos.y);\n  p.color = player.color;\n\n  let aim = new _Vector__WEBPACK_IMPORTED_MODULE_2__[\"default\"](1, 1);\n  aim.multiply(player.aim);\n  aim.normalize();\n  p.aim = aim;\n  \n  return p;\n}\n\n\n\n//# sourceURL=webpack:///./javascript/particle_factory.js?");

/***/ })

/******/ });